# -*- coding: utf-8 -*-
"""notebook_titik.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-jmpp2sL_t48tplJWP8F5BK8dnFqqsdQ

#Import Library
"""

from tqdm import tqdm # Library untuk bar progrss
import time
import warnings # Library untuk handle warning
warnings.filterwarnings('ignore') # Untuk mengignore beberapa warning yang kurang penting

# Library pemrosesan data
import pandas as pd
import numpy as np

# Library untuk menyimpan data
from google.colab import files

# Library untuk visualisasi data
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick
import seaborn as sns
try:
  import windrose
except ImportError:
  !pip install windrose
from windrose import WindroseAxes
import ipywidgets as widgets
from IPython.display import display
from statsmodels.tsa.seasonal import seasonal_decompose

# Library untuk metrik dan model selection
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import (
    KFold,
    cross_val_predict as cvp,
    cross_val_score as cvs
)
from sklearn.feature_selection import mutual_info_regression

# Library-library untuk model prediksi
!pip install catboost lightgbm
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor, ExtraTreesRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.pipeline import Pipeline
from sklearn.metrics import mean_squared_error, mean_absolute_error
import xgboost as xgb
import lightgbm as lgb
from sklearn.neighbors import KNeighborsRegressor
import catboost as cb

# Library untuk melakukan Hyperparameter Tuning
!pip install optuna
import optuna

# Library untuk menyimpan model
import pickle

# Supaya dapat melihat seluruh kolom
pd.set_option('display.max_columns', None)

# Inisiasi random state
SEED = 42

"""# Import Data"""

!gdown 1FRT9v2_At4xRuRI3dfPHmOBoCFLWH2sd
!gdown 16tY1OR4uveQDkd1DGDefz7SnN9yJwRWg
!gdown 1ZgXW9eVz54zi4zzsQ7yw-aEr8w7Te6Vh
!gdown 1C0lLbPvDCLGpfc9tyu0EdRxPDZa1mWgL
!gdown 1idMKdhkX5PaJZ2xkJIa58ExpCWCCepPj

# Load datasets
daily_train = pd.read_csv('/content/daily_train.csv')
daily_test = pd.read_csv('/content/daily_test.csv')
hourly_train = pd.read_csv('/content/hourly_train.csv')
hourly_test = pd.read_csv('/content/hourly_test.csv')
loc = pd.read_csv('/content/location.csv')

# Inspect data
print(daily_train.info())
print(daily_test.info())
print(hourly_train.info())
print(hourly_test.info())
print(loc.info())

"""# EDA & Pre-Processing

## Train
"""

daily_train.info()

hourly_train.info()

daily_train.head()

hourly_train.head()

"""### Missing Value and Duplicate"""

# Check for duplicate rows and missing values
print("\nNumber of duplicate rows in daily_train:", daily_train.duplicated().sum())
print("Number of duplicate rows in hourly_train:", hourly_train.duplicated().sum())
print("\nMissing values in daily_train:\n", daily_train.isnull().sum())
print("\nMissing values in hourly_train:\n", hourly_train.isnull().sum())

"""Tidak terdapat row duplikat ataupun missing value pada dataset daily_train dan hourly_train.

### Statistics Summary
"""

daily_train.describe().T

hourly_train.describe().T

"""### Monthly Rain Sum by Location"""

# Copy untuk keperluan EDA
dtrain = daily_train.copy()
htrain = hourly_train.copy()

# Ekstrak tahun dan bulan kolom time
dtrain['time'] = pd.to_datetime(dtrain['time'])
dtrain['year'] = dtrain['time'].dt.year
dtrain['month'] = dtrain['time'].dt.month
dtrain['day'] = dtrain['time'].dt.day

htrain['time'] = pd.to_datetime(htrain['time'])
htrain['year'] = htrain['time'].dt.year
htrain['month'] = htrain['time'].dt.month
htrain['day'] = htrain['time'].dt.day

# Merge dengan informasi dari dataset lokasi
dtrain = pd.merge(dtrain, loc[['location_id',  'elevation']], on='location_id', how='left')
htrain = pd.merge(htrain, loc[['location_id',  'elevation']], on='location_id', how='left')

# Line Chart for Rain Sum (monthly) over different years

for location_id in dtrain['location_id'].unique():
    location_data = dtrain[dtrain['location_id'] == location_id] # Filter per lokasi

    month_year_rain = location_data.groupby(['year', 'month'])['rain_sum (mm)'].mean().reset_index() # Agregat rata=rata per bulan
    month_year_pivot = month_year_rain.pivot(index='month', columns='year', values='rain_sum (mm)') # Pivot data per tahun

    # Plot data dengan matplotlib
    month_year_pivot.plot(marker='o', linewidth=2, figsize=(24, 12))
    plt.title(f"Monthly Rain Sum Trends Over Different Years for Location {location_id}, elevation : {loc.loc[location_id-1, 'elevation']}", fontsize=16)
    plt.xlabel("Month", fontsize=14)
    plt.ylabel("Average Rain Sum (mm)", fontsize=14)
    plt.xticks(ticks=range(1, 13), labels=["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], fontsize=12)
    plt.yticks(fontsize=12)

    plt.legend(title="Year", bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=12, title_fontsize=14)
    plt.grid(True)
    plt.tight_layout()
    plt.show()

"""Terlihat bahwa setiap tahun pasti ada tren penurunan (May - Sep) dan peningkatan curah hujan pada bulan-bulan tertentu. Pada beberapa lokasi dapat ditemukan rata-rata curah hujan yang cukup tinggi dibandingkan lainnya, seperti pada lokasi 8 dan 9."""

# Melihat curah hujan yang ekstem
dtrain[dtrain['rain_sum (mm)'] > 150]

"""Menurut [BMKG](https://www.bmkg.go.id/cuaca/probabilistik-curah-hujan.bmkg#:~:text=Ambang%20batas%20nilai%20yang%20digunakan%20untuk%20menentukan%20intensitas,%3E150%20mm%20%2F%20hari%20%28ungu%29%20%3A%20Hujan%20ekstrem), curah hujan >150 mm/hari berada pada kategori hujan ekstrem. Ini berarti curah hujan yang lebih dari 150 mm/hari dapat disebut sebagai cuaca ekstrem atau kejadian yang jarang terjadi. Terdapat lokasi-lokasi seperti Lokasi 8 dan Lokasi 9 yang mencatatkan curah hujan harian mencapai lebih dari 300 mm. Kemungkinan pada hari itu terjadi fenomena alam yang tidak biasa, seperti badai tropis atau curah hujan lebat yang berlangsung dalam waktu singkat.

Selanjutnya, kita akan mengeksplorasi salah satu kejadian curah hujan ekstrem, yaitu pada tanggal 17 Maret 2019 di lokasi 9.
"""

# Filter kembali untuk bulan dan lokasi yang diinginkan
dtrain_eks = dtrain[(dtrain['year'] == 2019) & (dtrain['month'] == 3) & (dtrain['location_id'] == 9)]

# Extract unique values directly from df_feb_eda
year = dtrain_eks['year'].unique()[0]
month = dtrain_eks['month'].unique()[0]
location_id = dtrain_eks['location_id'].unique()[0]

# Plot data curah hujan harian
plt.figure(figsize=(12, 6))
plt.plot(dtrain_eks['time'], dtrain_eks['rain_sum (mm)'], marker='o', linestyle='-', linewidth=2)
plt.title(f"Rain sum (mm) in {month}-{year} at Location {location_id}")
plt.xlabel("Date")
plt.ylabel("Daily Rainfall (mm)")
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

# Plot per Hour for Extreme Rain_sum
# Define the filter conditions
date_filter = (htrain['year'] == 2019) & (htrain['month'] == 3) & (htrain['day'] == 17) & (htrain['location_id'] == 9)
year = htrain[date_filter]['year'].unique()[0]
month = htrain[date_filter]['month'].unique()[0]
day = htrain[date_filter]['day'].unique()[0]
location_id = htrain[date_filter]['location_id'].unique()[0]

# Extract the data
hourly_temp = htrain[date_filter][['time', 'temperature_2m (°C)', 'apparent_temperature (°C)', 'dew_point_2m (°C)']]
hourly_cloud = htrain[date_filter][['time', 'cloud_cover_low (%)', 'cloud_cover_mid (%)', 'cloud_cover_high (%)']]
hourly_rad = htrain[date_filter][['time', 'shortwave_radiation_instant (W/m²)', 'direct_radiation_instant (W/m²)',
                                  'diffuse_radiation_instant (W/m²)', 'direct_normal_irradiance_instant (W/m²)']]
hourly_wind = htrain[date_filter][['time', 'wind_speed_10m (km/h)', 'wind_speed_100m (km/h)','wind_gusts_10m (km/h)']]

hourly_temp.set_index('time', inplace=True)
hourly_cloud.set_index('time', inplace=True)
hourly_rad.set_index('time', inplace=True)
hourly_wind.set_index('time', inplace=True)

# Subplot
fig, axes = plt.subplots(2, 2, figsize=(15, 15))  # 1 row, 2 columns

# Plot temperature data
hourly_temp.plot(ax=axes[0,0], marker='o', linestyle='-', linewidth=2)
axes[0,0].set(title=f"Hourly Temperature in {day:02d}-{month:02d}-{year} at Location {location_id}",
            xlabel="Time (Hours)", ylabel="Temperature (°C)")
axes[0, 0].tick_params(axis='x', rotation=45)

# Plot cloud cover data
hourly_cloud.plot(ax=axes[0, 1], marker='o', linestyle='-', linewidth=2)
axes[0, 1].set(title=f"Hourly Cloud Cover in {day:02d}-{month:02d}-{year} at Location {location_id}",
               xlabel="Time (Hours)", ylabel="Cloud Cover (%)")
axes[0, 1].tick_params(axis='x', rotation=45)

# Plot radiation data
hourly_rad.plot(ax=axes[1,0], marker='o', linestyle='-', linewidth=2)
axes[1,0].set(title=f"Hourly Radiations in {day:02d}-{month:02d}-{year} at Location {location_id}",
              xlabel="Time (Hours)", ylabel="Radiation instant (W/m²)")
axes[1,0].tick_params(axis='x', rotation=45)

# Plot wind data
hourly_wind.plot(ax=axes[1,1], marker='o', linestyle='-', linewidth=2)
axes[1,1].set(title=f"Hourly Wind Speed in {day:02d}-{month:02d}-{year} at Location {location_id}",
              xlabel="Time (Hours)", ylabel="Wind Speed & Gust (km/h)")
axes[1,1].tick_params(axis='x', rotation=45)

# Show plot
plt.tight_layout()
plt.show()

"""Plot di atas menunjukkan keadaan alam ketika terjadi hujan ekstrem pada lokasi 9 (308.8 mm).
- Dew point (titik embun) stabil sepanjang hari (~21°C) dan hampir sama dengan suhu lingkungan, menunjukkan kadar **kelembapan yang relatif tinggi**. Ini mendukung pembentukan awan dan potensi hujan.<sup>[[1]](https://ejournal-pusdiklat.bmkg.go.id/index.php/climago/article/view/71/40)</sup>
- Cloud Cover (mid dan high) cenderung banyak sepanjang hari, menunjukkan adanya perkembangan awan konvektif. Awan konvektif adalah awan yang dihasilkan oleh proses konveksi akibat pemanasan radiasi surya.<sup>[[2]](https://d1wqtxts1xzle7.cloudfront.net/70247371/1823-libre.pdf?1632659375=&response-content-disposition=inline%3B+filename%3DPotensi_Atmosfer_Dalam_Pembentukan_Awan.pdf&Expires=1732547985&Signature=Z8HdBhFwSFIuFXZsY2Wr6sN5TPlbbDaZqqBrRN0UWLb7vFaNICpe56DaAcceRWdhnKvVBsrIU1XO0L7~GW0m3Gu2B1g1eMAw-ivVq~1fWai09yXb0DOKHwDYmsWEavuoz8gBmCHp5JAQSwebSaYX-QiBmtiXcpc71OMzbOt1LTQJ7E64SrwFae3zGazeR6Vey7Ve8bSVktk6cXeVp1CEVP3h~iskfp1klY5op-u-4pbJ~ORHPJj6L3OhrDbKDJpQYyZyqIS2rVAqG8XbizA~19w-n0UBlhefgf28D0GoDvt44DUn8vrKzu2am9TTAhJ7e9dWY5uh8WRFCB41hGdi~Q__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA)</sup> Perkembangan  **awan  konvektif** sering  dikaitkan  dengan  **cuaca  buruk**  seperti badai petir, hujan lebat, tornado, angin kencang, hujan es, dan fenomena lainnya.<sup>[[3]](https://www.balai2bmkg.id/index.php/buletin_mkg/article/view/86/59)</sup>
- Pada grafik radiasi, terlihat bahwa `direct radiation` tetap rendah sepanjang hari, sedangkan diffuse radiation meningkat terutama di pagi-sore hari. Hal ini menunjukkan adanya tutupan awan yang cukup signifikan (sesuai dengan grafik `cloud cover`), sehingga radiasi langsung dari matahari terhambat dan lebih banyak tersebar oleh awan maupun partikel di atmosfer. Selain itu, direct normal irradiance hampir nol, menandakan bahwa kondisi atmosfer tidak mendukung penerimaan energi maksimum dari radiasi matahari karena sudut optimal terganggu oleh tutupan awan tebal.  
- Grafik angin menunjukkan kecepatan angin yang fluktuatif namun sering mengalami peningkatan signifikan. Ini menunjukkan adanya **aliran angin kuat** yang dapat **membawa massa udara lembap** ke lokasi tersebut, mendukung pembentukan awan hujan tebal.

Mari bandingkan plot di atas dengan plot fitur-fitur ketika hujan tidak ekstrem pada bulan, tahun, dan lokasi yang sama.
"""

# Plot per Hour for Not Extreme Rain_sum (34 mm)
# Define the filter conditions
date_filter = (htrain['year'] == 2019) & (htrain['month'] == 3) & (htrain['day'] ==13) & (htrain['location_id'] == 9)
year = htrain[date_filter]['year'].unique()[0]
month = htrain[date_filter]['month'].unique()[0]
day = htrain[date_filter]['day'].unique()[0]
location_id = htrain[date_filter]['location_id'].unique()[0]

# Extract the data
hourly_temp = htrain[date_filter][['time', 'temperature_2m (°C)', 'apparent_temperature (°C)', 'dew_point_2m (°C)']]
hourly_cloud = htrain[date_filter][['time', 'cloud_cover_low (%)', 'cloud_cover_mid (%)', 'cloud_cover_high (%)']]
hourly_rad = htrain[date_filter][['time', 'shortwave_radiation_instant (W/m²)', 'direct_radiation_instant (W/m²)',
                                  'diffuse_radiation_instant (W/m²)', 'direct_normal_irradiance_instant (W/m²)']]
hourly_wind = htrain[date_filter][['time', 'wind_speed_10m (km/h)', 'wind_speed_100m (km/h)','wind_gusts_10m (km/h)']]

hourly_temp.set_index('time', inplace=True)
hourly_cloud.set_index('time', inplace=True)
hourly_rad.set_index('time', inplace=True)
hourly_wind.set_index('time', inplace=True)

# Subplot
fig, axes = plt.subplots(2, 2, figsize=(15, 15))  # 1 row, 2 columns

# Plot temperature data
hourly_temp.plot(ax=axes[0,0], marker='o', linestyle='-', linewidth=2)
axes[0,0].set(title=f"Hourly Temperature in {day:02d}-{month:02d}-{year} at Location {location_id}",
            xlabel="Time (Hours)", ylabel="Temperature (°C)")
axes[0, 0].tick_params(axis='x', rotation=45)

# Plot cloud cover data
hourly_cloud.plot(ax=axes[0, 1], marker='o', linestyle='-', linewidth=2)
axes[0, 1].set(title=f"Hourly Cloud Cover in {day:02d}-{month:02d}-{year} at Location {location_id}",
               xlabel="Time (Hours)", ylabel="Cloud Cover (%)")
axes[0, 1].tick_params(axis='x', rotation=45)

# Plot radiation data
hourly_rad.plot(ax=axes[1,0], marker='o', linestyle='-', linewidth=2)
axes[1,0].set(title=f"Hourly Radiations in {day:02d}-{month:02d}-{year} at Location {location_id}",
              xlabel="Time (Hours)", ylabel="Radiation instant (W/m²)")
axes[1,0].tick_params(axis='x', rotation=45)

# Plot wind data
hourly_wind.plot(ax=axes[1,1], marker='o', linestyle='-', linewidth=2)
axes[1,1].set(title=f"Hourly Wind Speed in {day:02d}-{month:02d}-{year} at Location {location_id}",
              xlabel="Time (Hours)", ylabel="Wind Speed & Gust (km/h)")
axes[1,1].tick_params(axis='x', rotation=45)

# Adjust layout to prevent overlap
plt.tight_layout()

# Show the plot
plt.show()

"""- Dew point cenderung lebih rendah dari suhu lingkungan. Kelembapan relatif lebih rendah sehingga pembentukan awan dan potensi hujan lebih kecil.
-  Cloud cover low dan mid lebih bervariasi dan cenderung tidak banyak,menunjukkan kondisi langit yang lebih terbuka dan tidak tertutup awan.
- Secara keseluruhan, radiasi lebih tinggi dibandingkan dengan keadaan hujan ekstrem. Mencerminkan kondisi cuaca lebih sedikit hambatan awan dan agak cerah.
- Angin pada hujan tidak ekstrem tidak menunjukkan perbedaan yang signifikan dari hujan ekstrem. Kemungkinan angin tidak membawa massa udara lembap yang banyak untuk mendukung hujan lebat, namun hujan biasa.

### Rain Sum Distribution
"""

plt.figure(figsize=(12, 6))
sns.kdeplot(dtrain['rain_sum (mm)'], shade=True)
plt.title('Rain Sum (mm)')
plt.xlabel('Rain Sum (mm)')
plt.ylabel('Density')
plt.show()

# Calculate the density of rain_sum for each location
location_density = {}
for location_id in dtrain['location_id'].unique():
    location_data = dtrain[dtrain['location_id'] == location_id]
    location_density[location_id] = location_data['rain_sum (mm)'].values

# Subplots
fig, axes = plt.subplots(4, 3, figsize=(20, 15))
axes = axes.flatten()

# Plot density for each location
for i, location_id in enumerate(location_density):
    ax = axes[i]
    sns.kdeplot(location_density[location_id], shade=True, ax=ax)
    ax.set_title(f'Rain Sum Density for Location {location_id}, elevation : {loc.loc[location_id-1, "elevation"]}')
    ax.set_xlabel("Rain Sum (mm)")
    ax.set_ylabel("Density")

# Remove any unused subplots
for j in range(i + 1, len(axes)):
  fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

"""Secara keseluruhan, distribusi tampak miring ke kanan, yang menunjukkan bahwa sebagian besar curah hujan bernilai kecil dan curah hujan yang lebih tinggi jarang terjadi. Menurut [jurnal](https://ejurnal.undana.ac.id/FISA/article/view/2451#:~:text=Telah%20dilakukan%20analisis%20pola%20dan%20distribusi%20hujan%20berdasarkan,dan%20data%20periode%20curah%20hujan%20selama%20musim%20hujan.), lokasi dengan elevasi lebih tinggi cenderung memiliki curah hujan yang relatif lebih tinggi pula. Namun, dapat dilihat bahwa ada juga lokasi dengan elevasi rendah (lokasi 1, 7) yang memiliki curah hujan cukup tinggi. Hal ini menunjukkan bahwa faktor lain selain elevasi mungkin memengaruhi curah hujan di lokasi-lokasi tersebut.

### Sunshine Duration
"""

# Bar Chart Durasi Matahari 0

# Menyaring data untuk durasi sinar matahari = 0
dtrain_filtered = dtrain[dtrain['sunshine_duration (s)'] == 0]

# Membuat semua bulan (1-12) tersedia di setiap kombinasi 'location_id' dan 'year'
monthly_counts = (dtrain_filtered.groupby(['location_id', 'year', 'month'])
    .size()
    .unstack(fill_value=0)
    .reindex(columns=range(1, 13), fill_value=0)  # Pastikan bulan 1-12 selalu ada
)

# Membuat grafik untuk setiap lokasi
num_locations = dtrain_filtered['location_id'].nunique()
# Set ukuran untuk subplots: 2 kolom dan 6 baris
plt.figure(figsize=(14, 18))  # Menyesuaikan ukuran figure agar cukup besar
# Menentukan warna untuk setiap tahun
year_colors = {
    2019: '#80b3ff',  # Light Blue
    2020: '#99e699',  # Light Green
    2021: '#fff299',  # Light Yellow
    2022: '#ffb3d9',  # Light Pink
    2023: '#c2a2f0',  # Light Lavender
    2024: '#99ccff',  # Light Sky Blue
}

# Loop untuk setiap lokasi
for i, location in enumerate(dtrain_filtered['location_id'].unique()):
    ax = plt.subplot(6, 2, i + 1)  # 6 baris, 2 kolom, urutan lokasi i+1

    # Mengambil data untuk lokasi tertentu
    location_data = monthly_counts.loc[location]

    # Membuat stacked bar chart untuk lokasi tersebut
    bottom_values = [0] * 12  # Untuk menumpuk bar chart

    for year in location_data.index:
        # Plot data untuk tahun tertentu, menumpuk bar secara bertahap
        ax.bar(location_data.columns, location_data.loc[year], label=str(year),
               color=year_colors.get(year, 'gray'), bottom=bottom_values)

        # Memperbarui posisi bottom untuk tahun berikutnya
        bottom_values = [bottom + value for bottom, value in zip(bottom_values, location_data.loc[year])]

    # Menambahkan label dan judul
    ax.set_title(f'Jumlah Kejadian Sinar Matahari Nol per Bulan dan Tahun (Lokasi {location})')
    ax.set_xlabel('Bulan')
    ax.set_ylabel('Jumlah Kejadian')

    # Menyesuaikan xticks untuk bulan 1-12
    ax.set_xticks(range(1, 13))  # Mengatur posisi ticks bulan
    ax.set_xticklabels(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], rotation=45, ha='right')

    # Menyesuaikan sumbu y agar sesuai dengan nilai tertinggi
    ax.set_ylim(0, max(bottom_values) + 1)  # Atur batas sumbu y agar cukup tinggi untuk bar tertinggi

    # Menambahkan legenda di luar subplot
    plt.legend(title='Tahun', bbox_to_anchor=(1.05, 0.5), loc='center left')

# Menata layout dan Menampilkan Plot
plt.tight_layout()
plt.subplots_adjust(bottom=0.1)
plt.show()

"""Terlihat pola musiman yang jelas hampir di seluruh lokasi, dengan jumlah kejadian sinar matahari nol lebih tinggi pada awal dan akhir tahun, yang mengindikasikan kaitannya dengan musim hujan (atau dingin). Ini mendukung penjelasan pada line chart curah hujan per bulan sebelumnya.

### Relationship Between Elevation and Temperature
"""

# Membuat scatter plot untuk suhu maksimum, suhu minimum, dan suhu rata-rata terhadap elevasi
plt.figure(figsize=(10, 6))

# Plot suhu maksimum, minimum, dan rata-rata terhadap elevasi
sns.scatterplot(x=dtrain['elevation'], y=dtrain['temperature_2m_max (°C)'], label='Max Temperature', color='red')
sns.scatterplot(x=dtrain['elevation'], y=dtrain['temperature_2m_min (°C)'], label='Min Temperature', color='blue')
sns.scatterplot(x=dtrain['elevation'], y=dtrain['temperature_2m_mean (°C)'], label='Mean Temperature', color='green')

# Tambahkan label dan judul
plt.title('Hubungan antara Elevasi dan Suhu')
plt.xlabel('Elevasi (m)')
plt.ylabel('Suhu (°C)')
plt.legend()
plt.grid(True)
plt.show()

"""Umumnya, lokasi yang lebih tinggi akan memiliki suhu lingkungan yang lebih rendah dibandingkan lokasi yang lebih rendah. Berdasarkan plot di atas, benar terdapat tren bahwa suhu minimum di lokasi dengan elevasi lebih tinggi lebih rendah daripada suhu minimum di lokasi dengan elevasi lebih rendah. Begitupun sebaliknya, pada lokasi dengan elevasi lebih rendah, suhu maksimum cenderung lebih tinggi dibandingkan lokasi dengan elevasi lebih tinggi. Pola ini mungkin disebabkan oleh beberapa faktor, termasuk tekanan atmosfer yang lebih rendah pada ketinggian yang lebih tinggi dan ketersediaan radiasi matahari yang lebih sedikit.

### Wind Direction
"""

# Fungsi untuk mengkategorikan arah angin
def categorize_wind_direction(degree):
    if 337.5 <= degree or degree < 22.5:
        return 'N'
    elif 22.5 <= degree < 67.5:
        return 'NE'
    elif 67.5 <= degree < 112.5:
        return 'E'
    elif 112.5 <= degree < 157.5:
        return 'SE'
    elif 157.5 <= degree < 202.5:
        return 'S'
    elif 202.5 <= degree < 247.5:
        return 'SW'
    elif 247.5 <= degree < 292.5:
        return 'W'
    elif 292.5 <= degree < 337.5:
        return 'NW'

# Fungsi untuk plot Windrose
def plot_windrose(data, title):
    # Tambahkan kolom kategori arah angin
    data['wind_direction_category'] = data['wind_direction_10m_dominant (°)'].apply(categorize_wind_direction)
    locations = data['location_id'].unique()

    # Ukuran plot
    fig, axes = plt.subplots(4, 3, figsize=(20, 20), subplot_kw={'projection': 'windrose'})
    axes = axes.flatten()  # Mengubah array axes menjadi list untuk iterasi

    # Iterasi setiap lokasi
    for i, location in enumerate(locations[:12]):
        # Filter data untuk lokasi tertentu
        location_data = data[data['location_id'] == location]
        elevation = location_data['elevation'].iloc[0]

        # Ambil kecepatan dan arah angin
        ws = location_data['wind_speed_10m_max (km/h)'].to_numpy()  # Kecepatan angin
        wd = location_data['wind_direction_10m_dominant (°)'].to_numpy()  # Arah angin

        # Tentukan lebar bin dan rentang kecepatan angin
        width = 5
        maxVal = 30  # Nilai maksimal kecepatan angin
        windRange = np.arange(0, maxVal + width, width)  # Rentang kecepatan angin dalam bin

        # WindroseAxes
        ax = axes[i]
        ax.bar(wd, ws, bins=windRange, normed=True, opening=0.85, linewidth=0.5, edgecolor='black')

        # Title and Legend
        ax.set_title(f"Location {location}\nElevation: {elevation} m", fontsize=10)
        ax.set_legend(title="Kecepatan Angin (km/h)", loc='lower right', fontsize=8)

        # Format radius axis ke dalam persen
        fmt = '%.0f%%'
        yticks = mtick.FormatStrFormatter(fmt)
        ax.yaxis.set_major_formatter(yticks)

    # Sembunyikan sisa subplot jika jumlah lokasi < 12
    for j in range(len(locations), 12):
        fig.delaxes(axes[j])

    # Show Plot
    plt.suptitle(title, fontsize=14)
    plt.tight_layout()
    plt.show()

plot_windrose(dtrain, "Windrose\n")

# Statistik Wind Speed per Lokasi
wind_stats = dtrain.groupby('location_id')['wind_speed_10m_max (km/h)'].agg(['min', 'max', 'median'])
wind_stats.T

""" Berdasarkan plot windrose di atas, rentang kecepatan angin terlihat relatif serupa di berbagai elevasi. Tidak ada tren kuat yang mengindikasikan bahwa angin di lokasi tinggi selalu lebih cepat dibanding lokasi rendah. Lalu,  beberapa lokasi memiliki distribusi pola angin yang tersebar ke banyak arah, sementara lokasi lainnya menunjukkan pola angin yang terpusat ke satu arah."""

# Membandingkan Windrose untuk bulan-bulan tertentu

# Filter data
# Plot 1: Bulan 11, 12, 1, 2
plot1_data = dtrain[dtrain['month'].isin([11, 12, 1, 2])] # bulan dengan rain_sum cukup tinggi

# Plot 2: Bulan 5, 6, 7, 8
plot2_data = dtrain[dtrain['month'].isin([5, 6, 7, 8])] # bulan dengan rain_sum cukup rendah

# Fungsi untuk plot berdasarkan pilihan dropdown
def plot_based_on_selection(plot_selection):
    if plot_selection == 'Plot 1 (Nov-Feb)':
        plot_windrose(plot1_data, "Windrose for Months 11, 12, 1, 2\n")
    elif plot_selection == 'Plot 2 (May-Aug)':
        plot_windrose(plot2_data, "Windrose for Months 5, 6, 7, 8\n")

# Dropdown untuk memilih plot
dropdown = widgets.Dropdown(
    options=['Plot 1 (Nov-Feb)', 'Plot 2 (May-Aug)'],
    value='Plot 1 (Nov-Feb)',  # Default value
    description='Choose Plot:',
)

# Tampilkan dropdown dan Plot
widgets.interactive(plot_based_on_selection, plot_selection=dropdown)

"""Mengasumsikan `wind direction` atau arah angin yang dimaksud adalah "Dari mana angin bertiup", terlihat pola bahwa pada bulan basah (rain_sum cukup tinggi) angin cenderung bertiup dari arah Barat laut-Barat daya, kecuali untuk beberapa lokasi seperti lokasi 8 dan 9. Sementara itu, pada bulan kering (rain_sum cukup rendah) angin cenderung bertiup dari Timur laut-Tenggara, kecuali untuk beberapa lokasi.   

Pola ini sesuai dengan pola **angin muson**. Secara umum, angin muson adalah fenomena atmosfer yang terjadi karena adanya perbedaan tekanan udara antara daratan dan lautan yang berganti arah setiap setengah tahun/6 bulan. Pada periode muson barat (Oktober–Maret), angin bergerak dari belahan bumi utara menuju selatan, membawa uap air dari lautan menuju daratan di wilayah tropis. Pola ini biasanya menghasilkan musim hujan, ditandai dengan curah hujan yang cukup tinggi.   

Sebaliknya, pada periode muson timur (April–September), arah angin membawa udara kering dari wilayah subtropis menuju tropis. Angin ini menyebabkan musim kemarau di beberapa wilayah tropis.   

Pola angin pada wind rose di atas yang kurang sesuai dengan angin muson menandakan bahwa pada lokasi-lokasi tersebut angin juga dipengaruhi oleh pola angin lokal.

Sumber : [[1]](https://www.researchgate.net/profile/Widhiyanuriyawan-Denny/publication/315408702_Pemetaan_Potensi_Energi_Angin_di_Perairan_Indonesia_Berdasarkan_Data_Satelit_QuikScat_dan_WindSat/links/5921cc43aca27295a8a6401c/Pemetaan-Potensi-Energi-Angin-di-Perairan-Indonesia-Berdasarkan-Data-Satelit-QuikScat-dan-WindSat.pdf) [[2]](https://www.jurnalftijayabaya.ac.id/index.php/TREnD/article/view/179)

### Numeric Feature Correlation
"""

# Pilih kolom numerik saja
numeric_columns = dtrain.select_dtypes(include='float').columns

# Hitung matriks korelasi
correlation_matrix = dtrain[numeric_columns].corr(method='spearman')

# Plot heatmap korelasi
plt.figure(figsize=(12, 10))
sns.heatmap(correlation_matrix, annot=True, fmt='.2f', cmap='coolwarm', cbar=True)
plt.title('Heatmap Korelasi Antar Variabel Numerik')
plt.show()

"""- Suhu: Terdapat korelasi kuat (positif) antar variabel suhu, ini mengindikasikan bahwa suhu maksimum, minimum, dan rata-rata cenderung bergerak/berubah bersamaan.
- Radiasi Matahari & Evapotranspirasi: Korelasi positif yang sangat kuat antara radiasi matahari dan evapotranspirasi menandakan bahwa semakin banyak radiasi matahari yang diterima, semakin tinggi pula evapotranspirasi. Hal ini wajar karena radiasi matahari memang terdapat dalam rumus perhitungan et0 (FAO).
- Elevasi & Variabel Lainnya: Terdapat korelasi negatif antara elevasi dan beberapa variabel lainnya, terutama suhu, radiasi matahari, dan evapotranspirasi. Hal ini mengindikasikan bahwa semakin tinggi elevasi, semakin rendah suhu, radiasi matahari, dan evapotranspirasi, seperti yang telah dijelaskan pada plot sebelumnya.
- Durasi Siang : Terdapat korelasi positif cukup kuat antara durasi siang dan suhu, serta durasi siang dan radiasi matahari, menunjukkan bahwa suhu dan radiasi matahari cenderung lebih tinggi ketika durasi siang lebih panjang.
- Curah Hujan : Terdapat korelasi negatif antara curah hujan dengan suhu, `sunshine duration`, radiasi matahari, dan evapotranspirasi menunjukkan bahwa fitu-fitur tersebut cenderung lebih rendah ketika curah hujan lebih tinggi.
"""

# Memilih kolom-kolom yang diinginkan untuk pairplot
cols_to_plot = [
    'temperature_2m (°C)',
    'relative_humidity_2m (%)',
    'dew_point_2m (°C)',
    'apparent_temperature (°C)',
    'pressure_msl (hPa)',
    'surface_pressure (hPa)',
    'cloud_cover (%)',
    'cloud_cover_low (%)',
    'cloud_cover_mid (%)',
    'cloud_cover_high (%)',
    'et0_fao_evapotranspiration (mm)',
    'vapour_pressure_deficit (kPa)'
]

# Membuat pairplot dengan kolom-kolom yang dipilih
sns.pairplot(hourly_train[cols_to_plot])

# Menambahkan judul
plt.suptitle('Pairplot of Selected Weather Features', y=1.02)

# Menampilkan plot
plt.show()

"""### Outlier"""

# Boxplot fitur pada data daily_train
# Pilih kolom numerik yang ada di kedua dataset
numeric_columns = [col for col in daily_train.select_dtypes(include='float').columns if col in daily_test.columns]

# Atur grid untuk visualisasi
num_cols = 3  # Jumlah kolom dalam grid
num_rows = (len(numeric_columns) + num_cols - 1) // num_cols  # Hitung jumlah baris yang dibutuhkan

# Boxplot visualization for train data only
plt.figure(figsize=(15, 5 * num_rows))  # Adjust the figure size for train data

for i, column in enumerate(numeric_columns, 1):
    plt.subplot(num_rows, num_cols, i)  # Subplot for each column
    sns.boxplot(data=daily_train, x=column, color='blue')
    plt.title(f'Boxplot of {column} (Train)')
    plt.xlabel(column)

plt.tight_layout()  # Avoid overlap between subplots
plt.show()

"""Outlier tidak terlalu terlihat/berpengaruh.

### Merge
"""

# Konversi ke satuan MJ/m²
sum_col = [
    'direct_radiation_instant (W/m²)', 'diffuse_radiation_instant (W/m²)',
    'direct_normal_irradiance_instant (W/m²)', 'terrestrial_radiation_instant (W/m²)']

for col in sum_col:
    new_col_name = col.replace(' (W/m²)', ' (MJ/m²)')  # Mengubah nama kolom
    hourly_train[new_col_name] = (hourly_train[col] * 3600) / 1_000_000

# Hitung sum per hari
sum_col2 = [
    'direct_radiation_instant (MJ/m²)', 'diffuse_radiation_instant (MJ/m²)',
    'direct_normal_irradiance_instant (MJ/m²)', 'terrestrial_radiation_instant (MJ/m²)']

hourly_train['time'] = pd.to_datetime(hourly_train['time'])
hourly_train['date'] = hourly_train['time'].dt.date

hourly_sum = hourly_train.groupby(['location_id', 'date'])[sum_col2].sum()
hourly_sum.reset_index(inplace=True)

# Pengecualian kolom yang dijumlahkan
exclude_columns = [
    'direct_radiation_instant (MJ/m²)','diffuse_radiation_instant (MJ/m²)',
    'direct_normal_irradiance_instant (MJ/m²)','terrestrial_radiation_instant (MJ/m²)',
    'direct_radiation_instant (W/m²)', 'diffuse_radiation_instant (W/m²)',
    'direct_normal_irradiance_instant (W/m²)', 'terrestrial_radiation_instant (W/m²)',
    'shortwave_radiation_instant (W/m²)'
]

numeric_columns = hourly_train.select_dtypes(include=['float64']).columns
numeric_columns_to_include = [col for col in numeric_columns if col not in exclude_columns]

# Definisikan fungsi agregasi
aggregation_functions = {col: ['mean', 'max', 'min', 'std'] for col in numeric_columns_to_include}

# Agregasi hourly_train menjadi harian
hourly_aggregated = hourly_train.groupby(['location_id', 'date']).agg(aggregation_functions)

# Flatten MultiIndex columns
hourly_aggregated.columns = ['_'.join(col).strip() for col in hourly_aggregated.columns]
hourly_aggregated.reset_index(inplace=True)

# Merge hourly_sum and hourly_aggregated
hourly_agg = pd.merge(hourly_aggregated, hourly_sum, on=['location_id', 'date'], how='left')

daily_train['time'] = pd.to_datetime(daily_train['time'])
hourly_agg['date'] = pd.to_datetime(hourly_agg['date'])

daily_combined = pd.merge(daily_train, hourly_agg,
                          how='left',
                          left_on=['location_id', 'time'],
                          right_on=['location_id', 'date'])

train = pd.merge(daily_combined, loc, how='left', on='location_id')

train = train.drop(columns=['date', # drop kolom redundant
                            'temperature_2m (°C)_mean', 'temperature_2m (°C)_max','temperature_2m (°C)_min',
                            'apparent_temperature (°C)_mean',	'apparent_temperature (°C)_max',	'apparent_temperature (°C)_min',
                            'wind_speed_10m (km/h)_max', 'wind_gusts_10m (km/h)_max'])
train

train.columns

# Mengecek jumlah nilai kosong di setiap kolom
missing_values = train.isnull().sum()

# Menampilkan jumlah nilai kosong untuk semua kolom
print("Jumlah Nilai Kosong di Setiap Kolom:")
print(missing_values[missing_values > 0])  # Hanya menampilkan kolom yang memiliki nilai kosong

# Menampilkan jumlah total nilai kosong di seluruh dataset
total_missing = train.isnull().sum().sum()
print(f"\nTotal Nilai Kosong di Dataset: {total_missing}")

# Matrix Korelasi rain_sum dengan fitur hasil agregasi
correlation_matrix = train[['rain_sum (mm)', 'relative_humidity_2m (%)_mean',
                             'dew_point_2m (°C)_mean', 'pressure_msl (hPa)_mean', 'surface_pressure (hPa)_mean',
                             'cloud_cover (%)_mean',	'cloud_cover_low (%)_mean', 'cloud_cover_mid (%)_mean',
                             'cloud_cover_high (%)_mean', 'vapour_pressure_deficit (kPa)_mean', 'soil_temperature_0_to_7cm (°C)_mean',
                             'soil_temperature_7_to_28cm (°C)_mean', 'soil_temperature_28_to_100cm (°C)_mean',
                             'soil_temperature_100_to_255cm (°C)_mean', 'soil_moisture_0_to_7cm (m³/m³)_mean',
                             'soil_moisture_7_to_28cm (m³/m³)_mean', 'soil_moisture_28_to_100cm (m³/m³)_mean',
                             'soil_moisture_100_to_255cm (m³/m³)_mean','direct_radiation_instant (MJ/m²)',
                            'diffuse_radiation_instant (MJ/m²)', 'direct_normal_irradiance_instant (MJ/m²)',
                            'terrestrial_radiation_instant (MJ/m²)']].corr(method='spearman')

# Heatmap
plt.figure(figsize=(18, 13))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation between Aggregated Features')
plt.show()

"""**Korelasi antar fitur :**
- `vapour_pressure_deficit (kPa)_mean` dan `relative_humidity_2m (%)_mean`
 **Korelasi negatif yang sangat kuat** (-0.98) menunjukkan bahwa semakin rendah defisit tekanan uap, semakin tinggi kelembapan relatif. Hal ini masuk akal karena defisit tekanan uap adalah ukuran perbedaan antara jumlah uap air yang dapat ditampung udara dan jumlah uap air yang ada saat ini. Ketika kelembapan relatif mendekati 100% (udara jenuh), defisit tekanan uap akan mendekati nol.

- `soil_moisture_7_to_28cm_mean` dan `relative_humidity_2m (%)_mean` (r = 0.65)  
Kelembapan tanah yang tinggi berkaitan erat dengan kelembapan udara di atasnya. Ketika tanah memiliki kandungan air yang tinggi, terjadi proses evaporasi yang menghasilkan uap air di atmosfer, meningkatkan kelembapan relatif.

- Awan pada ketinggian menengah seringkali menunjukkan akumulasi uap air yang cukup untuk membentuk presipitasi. Awan jenis ini sering terlibat dalam proses hujan lebat karena mereka mengandung cukup banyak tetes air untuk bergabung dan jatuh sebagai hujan.

-  `soil_temperature_7_to_28cm_mean` dan `soil_moisture_7_to_28cm_mean` (r = -0.66)  
Ketika suhu tanah meningkat, kandungan air tanah pada lapisan tersebut cenderung menurun karena terjadinya proses penguapan. Suhu yang tinggi menyebabkan air di tanah menguap lebih cepat, sehingga kelembapan tanah juga akan berkurang.

- `cloud_cover_low (%)_mean` dan `relative_humidity_2m (%)_mean` (r = 0.58)  
Kelembapan udara yang tinggi cenderung mendukung pembentukan awan pada lapisan rendah. Ketika udara berada di dekat permukaan jenuh dengan uap air, uap ini akan mengembun membentuk awan rendah seperti stratus atau kabut.

**Korelasi Fitur dengan Target (`rain_sum (mm)`)**
- `relative_humidity_2m (%)_mean` (r = 0.81)  
Semakin tinggi kelembapan relatif udara, semakin banyak hujan yang terjadi. Hal ini masuk akal karena kelembapan relatif yang tinggi menunjukkan bahwa udara sudah hampir jenuh dengan uap air, yang bisa mengarah pada kondensasi dan hujan jika ada faktor lain yang mendukung (seperti pergerakan udara atau kondisi cuaca tertentu). ambil dr docs

- `dew_point_2m (°C)_mean`  (r = 0.53)  
semakin tinggi titik embun (dew point), semakin banyak hujan yang terjadi. Titik embun adalah suhu dimana udara harus didinginkan agar uap air mengembun menjadi cairan. Ketika titik embun tinggi, berarti udara lebih banyak mengandung uap air yang bisa menghasilkan hujan jika ada faktor kondensasi lainnya.

- `cloud_cover_mid (%)_mean` (r = 0.68)   
semakin banyak awan dengan ketinggian menengah (cloud cover mid), semakin tinggi jumlah hujan yang terjadi. Awan menengah (seperti altostratus) sering mengandung lebih banyak uap air yang dapat mengarah pada hujan lebat atau hujan sedang.

- `vapour_pressure_deficit (kPa)_mean` (r = -0.79)   
ketika defisit tekanan uap tinggi (udara lebih kering), curah hujan cenderung lebih rendah. Defisit tekanan uap adalah selisih antara kapasitas udara untuk menahan uap air dan jumlah uap air yang sebenarnya ada di udara. Ketika defisit tekanan uap tinggi, itu menunjukkan bahwa udara lebih kering dan kurang kondusif untuk hujan.

Kelembapan udara, kondisi awan, dan defisit tekanan uap memiliki hubungan yang kuat dengan jumlah curah hujan yang tercatat. Umumnya, semakin banyak uap air yang ada di udara (terlihat dari kelembapan relatif yang tinggi atau titik embun yang tinggi), semakin tinggi kemungkinan terjadinya hujan. Selain itu, keberadaan awan, baik rendah, menengah, atau tinggi, juga memainkan peran penting dalam mengindikasikan potensi hujan. Sebaliknya, defisit tekanan uap yang tinggi biasanya terkait dengan kondisi kering dan rendahnya kemungkinan hujan.

Kami memutuskan untuk menghapus outlier dari data Train.
"""

# Menghapus outlier pada rain sum

if 'rain_sum (mm)' in train.columns:
    # Filter data dengan rain_sum < 150
    train = train[train['rain_sum (mm)'] < 150]

"""## Test"""

daily_test.info()

daily_test.head()

hourly_test.info()

hourly_test.head()

"""### Statistic Summary"""

daily_test.describe().T

hourly_test.describe().T

"""### Missing Value and Duplicate"""

# Check for duplicate rows and missing values
print("\nNumber of duplicate rows in daily_test:", daily_test.duplicated().sum())
print("Number of duplicate rows in hourly_test:", hourly_test.duplicated().sum())
print("\nMissing values in daily_test:\n", daily_test.isnull().sum())
print("\nMissing values in hourly_test:\n", hourly_test.isnull().sum())

"""Terdapat 2 row missing value pada data daily_test dan 20/21 row missing value pada data hourly_test."""

# Baris dengan missing values pada data Daily
missing_rows = daily_test[daily_test.isnull().any(axis=1)]
missing_rows

"""Missing Value pada daily_test akan diimputasi secara manual dengan melihat data yang serupa pada waktu sebelumnya."""

# Isi nilai manual untuk missing data di lokasi 3 dan 10
daily_test.loc[(daily_test['location_id'] == 3) & (daily_test['et0_fao_evapotranspiration (mm)'].isnull()), 'et0_fao_evapotranspiration (mm)'] = 5.36
daily_test.loc[(daily_test['location_id'] == 3) & (daily_test['sunshine_duration (s)'].isnull()), 'sunshine_duration (s)'] = 40573.28
daily_test.loc[(daily_test['location_id'] == 3) & (daily_test['shortwave_radiation_sum (MJ/m²)'].isnull()), 'shortwave_radiation_sum (MJ/m²)'] = 24.34
daily_test.loc[(daily_test['location_id'] == 10) & (daily_test['et0_fao_evapotranspiration (mm)'].isnull()), 'et0_fao_evapotranspiration (mm)'] = 4.14
daily_test.loc[(daily_test['location_id'] == 10) & (daily_test['sunshine_duration (s)'].isnull()), 'sunshine_duration (s)'] = 35623.18
daily_test.loc[(daily_test['location_id'] == 10) & (daily_test['shortwave_radiation_sum (MJ/m²)'].isnull()), 'shortwave_radiation_sum (MJ/m²)'] = 19.88

# Cek hasil perubahan
missing_rows = daily_test[daily_test.isnull().any(axis=1)]
missing_rows

"""Untuk data hourly_test, dilakukan imputasi dengan mengisi data berdasarkan rata-rata tiap lokasi."""

# Imputasi NaN berdasarkan rata-rata per lokasi
columns_to_impute = [
    'et0_fao_evapotranspiration (mm)', 'shortwave_radiation_instant (W/m²)',
    'direct_radiation_instant (W/m²)', 'diffuse_radiation_instant (W/m²)',
    'direct_normal_irradiance_instant (W/m²)'
]

# Fungsi untuk imputasi
def impute_with_group_mean(df, column):
    return df.groupby('location_id')[column].transform(lambda x: x.fillna(x.mean()))

# Mengisi NaN untuk setiap kolom yang perlu diimputasi
for col in columns_to_impute:
    hourly_test[col] = impute_with_group_mean(hourly_test, col)

# Cek hasil imputasi
print(hourly_test.isnull().sum())

"""Missing value berhasil diimputasi.

### Outlier
"""

# Boxplot Daily
# Pilih hanya kolom numerik
numeric_columns = daily_test.select_dtypes(include=['float64', 'int64']).columns

# Tentukan ukuran grid untuk subplot
num_cols = 3  # Jumlah kolom dalam grid
num_rows = (len(numeric_columns) + num_cols - 1) // num_cols  # Hitung jumlah baris

# Plot boxplot untuk setiap kolom numerik
plt.figure(figsize=(15, 5 * num_rows))  # Ukuran gambar menyesuaikan jumlah baris
for i, column in enumerate(numeric_columns, 1):
    plt.subplot(num_rows, num_cols, i)
    sns.boxplot(data=daily_test, x=column, color='orange')
    plt.title(f'Boxplot of {column}')
    plt.xlabel(column)

# Mengatur tata letak untuk menghindari overlap
plt.tight_layout()
plt.show()

# Boxplot Hourly
# Pilih hanya kolom numerik
numeric_columns = hourly_test.select_dtypes(include=['float64', 'int64']).columns

# Tentukan ukuran grid untuk subplot
num_cols = 3  # Jumlah kolom dalam grid
num_rows = (len(numeric_columns) + num_cols - 1) // num_cols  # Hitung jumlah baris

# Plot boxplot untuk setiap kolom numerik
plt.figure(figsize=(15, 5 * num_rows))  # Ukuran gambar menyesuaikan jumlah baris
for i, column in enumerate(numeric_columns, 1):
    plt.subplot(num_rows, num_cols, i)
    sns.boxplot(data=hourly_test, x=column, color='orange')
    plt.title(f'Boxplot of {column}')
    plt.xlabel(column)

# Mengatur tata letak untuk menghindari overlap
plt.tight_layout()
plt.show()

"""Berdasarkan boxplot data Daily dan Hourly, terlihat bahwa ada outlier pada beberapa fitur seperti `apparent_temperature_max (°C)`, `shortwave_radiation_sum (MJ/M^2)`, `et0_fao_evapotranspiration (mm)`, dan lainnya."""

# Melihat row dengan outlier
# Kriteria outlier
criteria = (
    (daily_test['apparent_temperature_max (°C)'] > 100) |
    (daily_test['apparent_temperature_mean (°C)'] > 40) |
    (daily_test['shortwave_radiation_sum (MJ/m²)'] > 80) |
    (daily_test['et0_fao_evapotranspiration (mm)'] > 16)
)

# Baris yang memenuhi kriteria
filtered_rows = daily_test[criteria]

# Fungsi untuk mendapatkan baris sebelum dan sesudah
def get_surrounding_rows(df, index):
    start = max(index - 1, 0)
    end = min(index + 2, len(df))  # +2 karena slicing [start:end] eksklusif di akhir
    return df.iloc[start:end]

# Mendapatkan semua baris dengan tambahan sebelum dan sesudah
result = pd.concat([get_surrounding_rows(daily_test, idx) for idx in filtered_rows.index]).drop_duplicates()

# Tampilkan kolom tertentu (optional)
result = result[['location_id', 'time',
                 'apparent_temperature_max (°C)',
                 'apparent_temperature_mean (°C)',
                 'shortwave_radiation_sum (MJ/m²)',
                 'et0_fao_evapotranspiration (mm)']]

# Output hasil
result

"""Untuk mengatasi outlier pada data test, kami memutuskan untuk mengganti nilainya secara manual dengan melihat data pada hari-hari yang berdekatan."""

# 1. Untuk lokasi 10, apparent_temperature_max (°C) > 100 diganti dengan 39.5
daily_test.loc[
    (daily_test['location_id'] == 10) &
    (daily_test['apparent_temperature_max (°C)'] > 100),
    'apparent_temperature_max (°C)'
] = 39.5

# 2. Untuk lokasi 3, apparent_temperature_max (°C) > 100 diganti dengan 39.1
daily_test.loc[
    (daily_test['location_id'] == 3) &
    (daily_test['apparent_temperature_max (°C)'] > 100),
    'apparent_temperature_max (°C)'
] = 39.1

# 3. Untuk lokasi 10, apparent_temperature_mean (°C) > 40 diganti dengan 33.5
daily_test.loc[
    (daily_test['location_id'] == 10) &
    (daily_test['apparent_temperature_mean (°C)'] > 40),
    'apparent_temperature_mean (°C)'
] = 33.5

# 4. Untuk lokasi 10, shortwave_radiation_sum (MJ/m²) > 40 diganti dengan 20.33
daily_test.loc[
    (daily_test['location_id'] == 10) &
    (daily_test['shortwave_radiation_sum (MJ/m²)'] > 40),
    'shortwave_radiation_sum (MJ/m²)'
] = 20.33

# 5. Untuk lokasi 10, et0_fao_evapotranspiration (mm) > 14 diganti dengan 4.43
daily_test.loc[
    (daily_test['location_id'] == 10) &
    (daily_test['et0_fao_evapotranspiration (mm)'] > 14),
    'et0_fao_evapotranspiration (mm)'
] = 4.43

# Tampilkan hasil perubahan
print(daily_test.loc[[1468, 1469, 1470, 4904, 4905, 4906, 4907]])

# Boxplot setelah menangani outlier
# Pilih hanya kolom numerik
numeric_columns = daily_test.select_dtypes(include=['float64', 'int64']).columns

# Tentukan ukuran grid untuk subplot
num_cols = 3  # Jumlah kolom dalam grid
num_rows = (len(numeric_columns) + num_cols - 1) // num_cols  # Hitung jumlah baris

# Plot boxplot untuk setiap kolom numerik
plt.figure(figsize=(15, 5 * num_rows))  # Ukuran gambar menyesuaikan jumlah baris
for i, column in enumerate(numeric_columns, 1):
    plt.subplot(num_rows, num_cols, i)
    sns.boxplot(data=daily_test, x=column, color='orange')
    plt.title(f'Boxplot of {column}')
    plt.xlabel(column)

# Mengatur tata letak untuk menghindari overlap
plt.tight_layout()
plt.show()

"""### Merge

Fitur Radiasi pada data `hourly` memiliki satuan W/m2, untuk menyatukannya dengan data `daily`, akan diubah terlebih dulu satuannya menjadi MJ/m2 sebelum dihitung sumasinya.
"""

# Konversi ke satuan MJ/m²
sum_col = [
    'direct_radiation_instant (W/m²)', 'diffuse_radiation_instant (W/m²)',
    'direct_normal_irradiance_instant (W/m²)', 'terrestrial_radiation_instant (W/m²)']

for col in sum_col:
    new_col_name = col.replace(' (W/m²)', ' (MJ/m²)')  # Mengubah nama kolom
    hourly_test[new_col_name] = (hourly_test[col] * 3600) / 1_000_000

# Hitung sum per hari
sum_col2 = [
    'direct_radiation_instant (MJ/m²)', 'diffuse_radiation_instant (MJ/m²)',
    'direct_normal_irradiance_instant (MJ/m²)', 'terrestrial_radiation_instant (MJ/m²)']

hourly_test['time'] = pd.to_datetime(hourly_test['time'])
hourly_test['date'] = hourly_test['time'].dt.date

hourly_sum = hourly_test.groupby(['location_id', 'date'])[sum_col2].sum()
hourly_sum.reset_index(inplace=True)

# Pengecualian kolom yang dijumlahkan
exclude_columns = [
    'direct_radiation_instant (MJ/m²)','diffuse_radiation_instant (MJ/m²)',
    'direct_normal_irradiance_instant (MJ/m²)','terrestrial_radiation_instant (MJ/m²)',
    'direct_radiation_instant (W/m²)', 'diffuse_radiation_instant (W/m²)',
    'direct_normal_irradiance_instant (W/m²)', 'terrestrial_radiation_instant (W/m²)',
    'shortwave_radiation_instant (W/m²)'
]
numeric_columns = hourly_test.select_dtypes(include=['float64']).columns
numeric_columns_to_include = [col for col in numeric_columns if col not in exclude_columns]

# Definisikan fungsi agregasi
aggregation_functions = {col: ['mean', 'max', 'min', 'std'] for col in numeric_columns_to_include}

# Agregasi hourly_test menjadi harian
hourly_aggregated = hourly_test.groupby(['location_id', 'date']).agg(aggregation_functions)

# Flatten MultiIndex columns
hourly_aggregated.columns = ['_'.join(col).strip() for col in hourly_aggregated.columns]
hourly_aggregated.reset_index(inplace=True)

# Merge hourly_sum and hourly_aggregated
hourly_agg = pd.merge(hourly_aggregated, hourly_sum, on=['location_id', 'date'], how='left')

daily_test['time'] = pd.to_datetime(daily_test['time'])
hourly_agg['date'] = pd.to_datetime(hourly_agg['date'])

daily_combined = pd.merge(daily_test, hourly_agg,
                          how='left',
                          left_on=['location_id', 'time'],
                          right_on=['location_id', 'date'])

test = pd.merge(daily_combined, loc, how='left', on='location_id')

test = test.drop(columns=['date', # drop kolom redundant
                            'temperature_2m (°C)_mean', 'temperature_2m (°C)_max','temperature_2m (°C)_min',
                            'apparent_temperature (°C)_mean',	'apparent_temperature (°C)_max',	'apparent_temperature (°C)_min',
                            'wind_speed_10m (km/h)_max', 'wind_gusts_10m (km/h)_max'])
test

# Mengecek jumlah nilai kosong di setiap kolom
missing_values = test.isnull().sum()

# Menampilkan jumlah nilai kosong untuk semua kolom
print("Jumlah Nilai Kosong di Setiap Kolom:")
print(missing_values[missing_values > 0])  # Hanya menampilkan kolom yang memiliki nilai kosong

# Menampilkan jumlah total nilai kosong di seluruh dataset
total_missing = test.isnull().sum().sum()
print(f"\nTotal Nilai Kosong di Dataset: {total_missing}")

"""# Feature Engineering"""

def get_season(month):
    if month in [12, 1, 2]:
        return 'rainy'
    elif month in [3, 4, 5]:
        return 'transitional_1'
    elif month in [6, 7, 8]:
        return 'dry'
    elif month in [9, 10, 11]:
        return 'transitional_2'

def categorize_wind_speed(speed):
    if speed < 10:
        return 'low'
    elif 10 <= speed < 20:
        return 'moderate'
    elif 20 <= speed < 30:
        return 'high'
    else:
        return 'storm'

# Fungsi untuk mengkategorikan temperatur mean
def categorize_temperature_mean(temp):
    if temp < 15:
        return 'cold'
    elif 15 <= temp < 30:
        return 'moderate'
    else:
        return 'hot'


def feature_engineering(df):
    # Mengonversi kolom 'time' menjadi datetime
    df['time'] = pd.to_datetime(df['time'])

    # Ekstrak fitur dari waktu
    df['day'] = df['time'].dt.day
    df['month'] = df['time'].dt.month
    df['year'] = df['time'].dt.year
    df['day_of_year'] = df['time'].dt.dayofyear
    df['week_of_year'] = df['time'].dt.isocalendar().week
    df['day_of_week'] = df['time'].dt.dayofweek
    df['is_weekend'] = df['day_of_week'].apply(lambda x: 1 if x >= 5 else 0)

    # Temperatur
    df['temperature_range'] = df['temperature_2m_max (°C)'] - df['temperature_2m_min (°C)']
    df['daily_temperature_range'] = df['temperature_2m_max (°C)'] - df['temperature_2m_min (°C)']
    df['temperature_gradient'] = df['temperature_2m_mean (°C)'].diff().fillna(0)
    df['temp_pressure_humidity_interaction'] = (
        df['temperature_2m_mean (°C)'] *
        df['relative_humidity_2m (%)_mean'] /
        df['pressure_msl (hPa)_mean']
    )
    df['temp_humidity_interaction'] = df['temperature_2m_mean (°C)'] * df['relative_humidity_2m (%)_mean']
    df['temp_elevation_interaction'] = df['temperature_2m_mean (°C)'] / df['elevation']

    # Sunshine dan Radiasi
    df['sunshine_ratio'] = df['sunshine_duration (s)'] / df['daylight_duration (s)']
    df['radiation_daylight_interaction'] = df['shortwave_radiation_sum (MJ/m²)'] / df['daylight_duration (s)']
    df['radiation_gradient'] = df['shortwave_radiation_sum (MJ/m²)'].diff().fillna(0)

    # Elevasi dan Interaksi
    df['elevation_group'] = pd.cut(df['elevation'], bins=[0, 100, 500, 1000, 3000], labels=['low', 'medium', 'high', 'very_high'])

    # Angin
    df['wind_speed_range'] = df['wind_speed_10m_max (km/h)'] - df['wind_speed_10m (km/h)_min']
    df['wind_speed_gradient'] = df['wind_speed_10m (km/h)_mean'].diff().fillna(0)
    df['wind_pressure_ratio'] = df['wind_speed_10m (km/h)_mean'] / df['pressure_msl (hPa)_mean']

    # Geografi
    df['abs_latitude'] = df['x'].abs()
    df['latitude_longitude_interaction'] = df['x'] * df['y']
    df['distance_from_equator'] = df['x'].apply(lambda lat: np.sqrt(lat**2))

    # Elevasi Berdasarkan Kelompok
    df['elevation_mean_by_group'] = df.groupby('elevation_group')['elevation'].transform('mean')  # Rata-rata elevasi per grup

    # Cloud dan Kelembapan
    df['heavy_cloud_indicator'] = df['cloud_cover (%)_mean'] * df['vapour_pressure_deficit (kPa)_mean']
    df['season'] = df['month'].apply(get_season)

    # Wind Speed and Direction (Features with Transformation)
    df['wind_speed_max_min_difference'] = df['wind_speed_10m_max (km/h)'] - df['wind_speed_10m (km/h)_min']
    df['wind_direction_diff'] = df['wind_direction_10m_dominant (°)'] - df['wind_direction_10m (°)_mean']

    # Latitude-Longitude Interaction Features
    df['latitude_longitude_interaction'] = df['x'] * df['y']

    df.rename(columns={'apparent_temperature (°C)_max': 'apparent_temperature_max (°C)'}, inplace=True)

    # Fitur Temporal
    df['sin_day_of_year'] = np.sin(2 * np.pi * df['day_of_year'] / 365.25)
    df['cos_day_of_year'] = np.cos(2 * np.pi * df['day_of_year'] / 365.25)

    # Fitur Atmosferik
    df['dewpoint_deficit'] = df['temperature_2m_mean (°C)'] - df['dew_point_2m (°C)_mean']
    df['humidity_pressure_ratio'] = df['relative_humidity_2m (%)_mean'] / df['pressure_msl (hPa)_mean']

    # Fitur Awan
    df['cloud_variability'] = df['cloud_cover (%)_max'] - df['cloud_cover (%)_min']
    df['high_cloud_to_total_ratio'] = df['cloud_cover_high (%)_mean'] / (df['cloud_cover (%)_mean'] + 1e-5)

    # Fitur Tanah
    df['soil_moisture_ratio'] = df['soil_moisture_0_to_7cm (m³/m³)_mean'] / (df['soil_moisture_100_to_255cm (m³/m³)_mean'] + 1e-5)
    df['soil_moisture_variability'] = df['soil_moisture_0_to_7cm (m³/m³)_max'] - df['soil_moisture_0_to_7cm (m³/m³)_min']

    # Fitur Angin
    df['storm_indicator'] = ((df['wind_gusts_10m_max (km/h)'] > 30) & (df['pressure_msl (hPa)_mean'] < 1000)).astype(int)
    df['wind_energy_potential'] = 0.5 * (df['wind_speed_10m (km/h)_mean'] ** 3)

    # Fitur Radiasi
    df['sunshine_to_radiation_ratio'] = df['sunshine_duration (s)'] / (df['shortwave_radiation_sum (MJ/m²)'] + 1e-5)

    # Fitur Interaksi
    df['humidity_radiation_interaction'] = df['relative_humidity_2m (%)_mean'] * df['shortwave_radiation_sum (MJ/m²)']
    df['wind_pressure_interaction'] = df['wind_speed_10m (km/h)_mean'] * df['pressure_msl (hPa)_mean']

    df['wind_speed_category'] = df['wind_speed_10m (km/h)_mean'].apply(categorize_wind_speed)

    # Kategori temperatur mean
    df['temperature_category_mean'] = df['temperature_2m_mean (°C)'].apply(categorize_temperature_mean)

    # Mengubah tipe data
    categorical_features = ['elevation_group', 'season', 'wind_speed_category', 'temperature_category_mean', 'is_weekend']
    for feature in categorical_features:
        df[feature] = df[feature].astype('category')
    df['week_of_year'] = df['week_of_year'].astype('int32')

    df['temp_humidity_interaction_squared'] = df['temp_humidity_interaction'] ** 2
    df['wind_pressure_interaction_squared'] = df['wind_pressure_interaction'] ** 2
    df['radiation_sunshine_interaction'] = df['shortwave_radiation_sum (MJ/m²)'] * df['sunshine_duration (s)']
    df['log_dewpoint_deficit'] = np.log1p(df['dewpoint_deficit'])
    df['soil_temperature_difference'] = df['soil_temperature_0_to_7cm (°C)_mean'] - df['soil_temperature_28_to_100cm (°C)_mean']
    df['wind_direction_radians'] = np.radians(df['wind_direction_10m_dominant (°)'])
    df['extreme_temp'] = (df['temperature_2m_max (°C)'] > 35).astype(int)
    df['high_humidity'] = (df['relative_humidity_2m (%)_max'] > 90).astype(int)
    df['low_pressure'] = (df['pressure_msl (hPa)_min'] < 1000).astype(int)

    columns_to_drop = [
      'ID',
      'location_id',
      'time',
      'sunrise (iso8601)',
      'sunset (iso8601)',
      'x',
      'y',
      'daily_temperature_range'
    ]

    # Drop kolom dari train
    df = df.drop(columns=columns_to_drop)

    return df


train = feature_engineering(train)
test = feature_engineering(test)

train

test

"""# Modelling

## Feature Selection

### Mutual Information
"""

# Step 1: Transformasi log pada target
train['log_rain_sum'] = np.log1p(train['rain_sum (mm)'])  # log(1 + y)
y_train = train['log_rain_sum']

# Step 2: Pisahkan fitur numerik dan kategorik
numerical_features = train.select_dtypes(include=['number']).drop(columns=['rain_sum (mm)', 'log_rain_sum'])
categorical_features = train.select_dtypes(exclude=['number']).columns.tolist()

# Menampilkan semua fitur sebelum seleksi
all_features = numerical_features.columns.tolist() + categorical_features
print("Fitur Sebelum Seleksi:")
print(all_features)
print(f"Jumlah Fitur Sebelum Seleksi: {len(all_features)}\n")

# Step 3: Hitung Mutual Information untuk fitur numerik
mi_scores = mutual_info_regression(numerical_features, y_train, random_state=SEED)
mi_scores = pd.Series(mi_scores, index=numerical_features.columns).sort_values(ascending=False)

# Step 4: Tampilkan skor Mutual Information
print("Mutual Information Scores:")
print(mi_scores)

# Step 5: Pilih fitur numerik dengan skor MI di atas threshold
threshold = 0.01  # Atur threshold sesuai kebutuhan
selected_numerical_features = mi_scores[mi_scores > threshold].index.tolist()

# Gabungkan fitur numerik terpilih dengan fitur kategorik
final_selected_features = selected_numerical_features + categorical_features

# Step 6: Dataset Train dan Test dengan fitur terpilih
X_train_selected = train[final_selected_features]
X_test_selected = test[final_selected_features]

# Menampilkan semua fitur setelah seleksi
print("\nFitur Setelah Seleksi:")
print(final_selected_features)
print(f"Jumlah Fitur Setelah Seleksi: {len(final_selected_features)}\n")

"""### Handle Multicollinearity"""

# Step 1: Pilih hanya fitur numerik
numerical_features = X_train_selected.select_dtypes(include=['number'])

# Step 2: Hitung matriks korelasi
correlation_matrix = numerical_features.corr().abs()

# Step 3: Identifikasi pasangan fitur dengan korelasi di atas 0.95
upper_triangle = correlation_matrix.where(np.triu(np.ones(correlation_matrix.shape), k=1).astype(bool))
high_correlation_pairs = [
    (column, index, upper_triangle.loc[index, column])
    for column in upper_triangle.columns
    for index in upper_triangle.index
    if upper_triangle.loc[index, column] > 0.95
]

# Konversi pasangan korelasi tinggi ke DataFrame
high_correlation_df = pd.DataFrame(high_correlation_pairs, columns=['Feature 1', 'Feature 2', 'Correlation'])

# Tampilkan DataFrame pasangan korelasi tinggi
print("High Correlation Pairs (> 0.95):")
print(high_correlation_df)

# Step 4: Drop salah satu fitur dari setiap pasangan berdasarkan MI
features_to_drop = set()
for col1, col2, _ in high_correlation_pairs:
    if col1 in mi_scores and col2 in mi_scores:
        # Drop fitur dengan skor MI lebih rendah
        if mi_scores[col1] < mi_scores[col2]:
            features_to_drop.add(col1)
        else:
            features_to_drop.add(col2)

# Hapus fitur yang dipilih untuk di-drop
X_train_selected_final = X_train_selected.drop(columns=features_to_drop)
X_test_selected_final = X_test_selected.drop(columns=features_to_drop)

# Tampilkan fitur yang di-drop dan fitur tersisa
print("\nFeatures to Drop (Multicollinearity > 0.95):")
print(pd.DataFrame(list(features_to_drop), columns=['Dropped Features']))

print("\nRemaining Features After Multicollinearity Analysis:")
print(pd.DataFrame(X_train_selected_final.columns.tolist(), columns=['Remaining Features']))

"""## Model Selection"""

# Data Preparation
X_train = X_train_selected_final.copy()  # Selected features
X_test = X_test_selected_final.copy()  # Test set features

# Encoding Categoric Variable
# Identify categorical columns
categorical_cols = X_train.select_dtypes(include=['category', 'object']).columns

# Perform one-hot encoding
X_train = pd.get_dummies(X_train, columns=categorical_cols, drop_first=True)
X_test = pd.get_dummies(X_test, columns=categorical_cols, drop_first=True)

# Split train data into train and validation sets
X_train_split, X_valid_split, y_train_split, y_valid_split = train_test_split(
    X_train, y_train, test_size=0.2, random_state=SEED
)

# Pipelines untuk model
pipelines = {
    'RandomForest': Pipeline([
        ('model', RandomForestRegressor(random_state=SEED))
    ]),
    'GradientBoosting': Pipeline([
        ('model', GradientBoostingRegressor(random_state=SEED))
    ]),
    'XGBoost': Pipeline([
        ('model', xgb.XGBRegressor(random_state=SEED))
    ]),
    'LightGBM': Pipeline([
        ('model', lgb.LGBMRegressor(random_state=SEED))
    ]),
    'KNN': Pipeline([
        ('model', KNeighborsRegressor())
    ]),
    'DecisionTree': Pipeline([
        ('model', DecisionTreeRegressor(random_state=SEED))
    ]),
    'CatBoost': Pipeline([
        ('model', cb.CatBoostRegressor(random_state=SEED, verbose=100))
    ]),
    'ExtraTrees': Pipeline([
        ('model', ExtraTreesRegressor(random_state=SEED))
    ])
}

# Fungsi untuk evaluasi model
def evaluate_model(model, X_train, y_train, X_val, y_val):
    model.fit(X_train, y_train)

    # Prediksi pada validation set
    y_pred = model.predict(X_val)
    y_pred = np.expm1(y_pred)  # Transformasi balik dari log scale

    mse = mean_squared_error(np.expm1(y_val), y_pred)
    rmse = np.sqrt(mse)
    mae = mean_squared_error(np.expm1(y_val), y_pred)

    return mse, rmse, mae, y_pred

# Evaluasi setiap model dan tampilkan metriknya
for name, model in pipelines.items():
    print(f"Evaluating {name}...")
    mse, rmse, mae, y_pred = evaluate_model(model, X_train_split, y_train_split, X_valid_split, y_valid_split)
    print(f"  MSE: {mse:.4f}")
    print(f"  RMSE: {rmse:.4f}")
    print(f"  MAE: {mae:.4f}")
    print()

"""Kami memutuskan untuk memilih model **Catboost** karena memiliki MSE paling kecil di antara semua model

## Final Model
"""

final_model = cb.CatBoostRegressor(iterations = 1500, loss_function = 'RMSE', depth = 6,
                                   learning_rate = 0.05, l2_leaf_reg = 10, bagging_temperature = 0.8,
                                   random_strength = 0.7, od_type = 'Iter', early_stopping_rounds=50,
                                   random_state=SEED, verbose=100)
final_model.fit(X_train_split, y_train_split)

# Predict
y_valid_pred_log = final_model.predict(X_valid_split)
y_valid_pred = np.expm1(y_valid_pred_log)  # Transform back from log scale
y_valid_pred = np.maximum(0, y_valid_pred)  # Ensure no negative values

# Calculate MSE, RMSE, and R² for validation set
mse = mean_squared_error(np.expm1(y_valid_split), y_valid_pred)  # Mean Squared Error
rmse = np.sqrt(mse)  # Root Mean Squared Error
r2 = r2_score(np.expm1(y_valid_split), y_valid_pred)  # R² Score

# Print results
print(f"Validation MSE: {mse:.4f}")
print(f"Validation RMSE: {rmse:.4f}")
print(f"Validation R²: {r2:.4f}")

"""## Feature Importance"""

feat_importance = final_model.get_feature_importance()
feature_importance_df = pd.DataFrame({'Feature': X_train_split.columns, 'Importance': feat_importance})
feature_importance_df = feature_importance_df.sort_values(by='Importance', ascending=False)
feature_importance_df = feature_importance_df[:15]

plt.figure(figsize=(10, 8))
plt.barh(feature_importance_df['Feature'], feature_importance_df['Importance'])
plt.xlabel('Importance')
plt.title('15 Highest Feature Importance for Catboost Model')
plt.gca().invert_yaxis()
plt.show()

"""# Final Training, Save Model, Prediction, Postprocessing, and Submission"""

final_model = cb.CatBoostRegressor(iterations = 1500, loss_function = 'RMSE', depth = 6,
                                   learning_rate = 0.05, l2_leaf_reg = 10, bagging_temperature = 0.8,
                                   random_strength = 0.7, od_type = 'Iter', early_stopping_rounds=50,
                                   random_state=SEED, verbose=100)
final_model.fit(X_train, y_train)
with open("catboost_model.pkl", "wb") as file:
    pickle.dump(final_model, file)

with open("catboost_model.pkl", "rb") as file:
    final_cb_model = pickle.load(file)

train = pd.concat([X_train_selected_final, y_train], axis=1)
test = X_test_selected_final

# Simpan hasil ke file CSV
train.to_csv("train_titik.csv", index=False)
test.to_csv("test_titik.csv", index=False)

# Unduh file
files.download("train_titik.csv")
files.download("test_titik.csv")

print("Gabungan data selesai! File disimpan sebagai train_titik.csv dan test_titik.csv")

!gdown 1Kd9XFHuE7jeK51en8zbpCHjiWjwo90BZ

sample = pd.read_csv('/content/sample_submission.csv')

# Predict on Test Data
y_test_pred_log = final_model.predict(X_test)
y_test_pred = np.expm1(y_test_pred_log)  # Transform back from log scale
y_test_pred = np.maximum(0, y_test_pred)  # Ensure no negative values

# Prepare Submission for Kaggle
# Replace 'ID' with the actual ID column in your test data
submission = pd.DataFrame({'ID': sample['ID'], 'rain_sum (mm)': y_test_pred})

# Save to CSV
submission.to_csv('submission.csv', index=False)
print("Submission file saved as 'submission.csv'")